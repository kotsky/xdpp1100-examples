
/**
 * @file    ./src/user_app/pmbus_mfr_autogen.h
 * @brief   Automatically generated from output of pmbus compile script.
 */

/* ============================================================================
** Copyright (C) 2020 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
**
** Automatically generated by:  pmbus_xlsx2c.py shasta_pmbus.xlsx
** Created on:  2020-09-08
*/
/*lint -save -e960 */

#include <stdint.h>              /* uint*_t */
#include "fw_bool.h"             /* boolean type */
#include "pmbus_autogen.h"
#include "pmbus_mfr_autogen.h"




/* instantiate the command MFR_OVP_FAULT_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_OVP_FAULT_LIMIT;
uint8_t	PMBUS_CMD_MFR_OVP_FAULT_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_OVP_FAULT_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_OVP_FAULT_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command MFR_OVP_FAULT_RESPONSE.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_OVP_FAULT_RESPONSE;
uint8_t	PMBUS_CMD_MFR_OVP_FAULT_RESPONSE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_OVP_FAULT_RESPONSE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command MFR_VIN_UV_FAULT_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT;
uint8_t	PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)

/* instantiate the command MFR_VIN_UV_FAULT_RESPONSE.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE;
uint8_t	PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/*
 * Initializes all of our pmbus structs that were generated by the script
 * Function gets called to setup command support array, initialize pointers to command data, and describe commands 
 */
void pmbus_mfr_autogen_init(void)
{


	/* initialize command structure for MFR_OVP_FAULT_LIMIT. */
	// MFR_OVP_FAULT_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_OVP_FAULT_LIMIT] = PMBUS_HANDLE_MFR_OVP_FAULT_LIMIT;
	//PMBUS_CMD_MFR_OVP_FAULT_LIMIT.OPCODE = PMBUS_CMDCODE_MFR_OVP_FAULT_LIMIT;
	//PMBUS_CMD_MFR_OVP_FAULT_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_OVP_FAULT_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_OVP_FAULT_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_OVP_FAULT_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_OVP_FAULT_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_MFR_OVP_FAULT_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_OVP_FAULT_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_OVP_FAULT_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_MFR_OVP_FAULT_LIMIT.RANGE = &PMBUS_CMD_MFR_OVP_FAULT_LIMIT_RANGE[0];
	PMBUS_CMD_MFR_OVP_FAULT_LIMIT.CMD_CONFIG = 0xc88223b1;
	PMBUS_CMD_MFR_OVP_FAULT_LIMIT.DATA0 = &PMBUS_CMD_MFR_OVP_FAULT_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_OVP_FAULT_LIMIT.DATA1 = &PMBUS_CMD_MFR_OVP_FAULT_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_OVP_FAULT_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_OVP_FAULT_LIMIT] = &PMBUS_CMD_MFR_OVP_FAULT_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_OVP_FAULT_LIMIT] = &PMBUS_CMD_MFR_OVP_FAULT_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_OVP_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_OVP_FAULT_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_OVP_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_OVP_FAULT_LIMIT&31u));

	/* initialize command structure for MFR_OVP_FAULT_RESPONSE. */
	// MFR_OVP_FAULT_RESPONSE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_OVP_FAULT_RESPONSE] = PMBUS_HANDLE_MFR_OVP_FAULT_LIMIT;
	//PMBUS_CMD_MFR_OVP_FAULT_RESPONSE.OPCODE = PMBUS_CMDCODE_MFR_OVP_FAULT_RESPONSE;
	//PMBUS_CMD_MFR_OVP_FAULT_RESPONSE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_OVP_FAULT_RESPONSE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_OVP_FAULT_RESPONSE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_OVP_FAULT_RESPONSE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_OVP_FAULT_RESPONSE.SUPPORTED = 1;
	//PMBUS_CMD_MFR_OVP_FAULT_RESPONSE.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_OVP_FAULT_RESPONSE.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_OVP_FAULT_RESPONSE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_OVP_FAULT_RESPONSE.CMD_CONFIG = 0xc18123b2;
	PMBUS_CMD_MFR_OVP_FAULT_RESPONSE.DATA0 = &PMBUS_CMD_MFR_OVP_FAULT_RESPONSE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_OVP_FAULT_RESPONSE.DATA1 = &PMBUS_CMD_MFR_OVP_FAULT_RESPONSE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_OVP_FAULT_RESPONSE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_OVP_FAULT_RESPONSE] = &PMBUS_CMD_MFR_OVP_FAULT_RESPONSE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_OVP_FAULT_RESPONSE] = &PMBUS_CMD_MFR_OVP_FAULT_RESPONSE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_OVP_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_OVP_FAULT_RESPONSE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_OVP_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_OVP_FAULT_RESPONSE&31u));

	/* initialize command structure for MFR_VIN_UV_FAULT_LIMIT. */
	// MFR_VIN_UV_FAULT_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_VIN_UV_FAULT_LIMIT] = PMBUS_HANDLE_MFR_VIN_UV_FAULT_LIMIT;
	//PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT.OPCODE = PMBUS_CMDCODE_MFR_VIN_UV_FAULT_LIMIT;
	//PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT.CMD_CONFIG = 0xc18223b3;
	PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT.DATA0 = &PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT.DATA1 = &PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_VIN_UV_FAULT_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_UV_FAULT_LIMIT] = &PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_UV_FAULT_LIMIT] = &PMBUS_CMD_MFR_VIN_UV_FAULT_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_UV_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_UV_FAULT_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_UV_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_UV_FAULT_LIMIT&31u));

	/* initialize command structure for MFR_VIN_UV_FAULT_RESPONSE. */
	// MFR_VIN_UV_FAULT_RESPONSE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_VIN_UV_FAULT_RESPONSE] = PMBUS_HANDLE_MFR_VIN_UV_FAULT_LIMIT;
	//PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE.OPCODE = PMBUS_CMDCODE_MFR_VIN_UV_FAULT_RESPONSE;
	//PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE.SUPPORTED = 1;
	//PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE.CMD_CONFIG = 0xc18123b4;
	PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE.DATA0 = &PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE.DATA1 = &PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_VIN_UV_FAULT_RESPONSE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_UV_FAULT_RESPONSE] = &PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_UV_FAULT_RESPONSE] = &PMBUS_CMD_MFR_VIN_UV_FAULT_RESPONSE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_UV_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_UV_FAULT_RESPONSE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_UV_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_UV_FAULT_RESPONSE&31u));

}


