/*
 * user_app.c
/* ============================================================================
** Copyright (C) 2020 Infineon. All rights reserved.
**               Infineon Technologies, PSS SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
**
** Created on:  2020-08-19
*/


#include "dtimer_drv.h"
#include "telemetry_drv.h"
#include "regulation_api.h"
#include "faults_api.h"
#include "faults_drv.h"
#include "pmbus_api.h"
#include "pmbus_gpio_control.h"
#include "shasta_hal_vsen.h"
#include "shasta_hal_vcontrol.h"
#include "shasta_hal_pwm.h"
#include "shasta_hal_pid.h"
#include "shasta_hal_scu.h"
#include "shasta_hal_cgu.h"
#include "shasta_hal_rgu.h"
#include "shasta_hal_telem.h"
#include "shasta_hal_common.h"
#include "shasta_hal_fault.h"
#include "shasta_hal_isen.h"
#include "regulation_state_machine_callbacks.h"
#include "pmbus_autogen.h"
#include "pmbus_mfr_autogen.h"
#include "user_app.h"
#include "cmsis_os.h"                   // ARM::CMSIS:RTOS:Keil RTX
#include "cmsis_os_ext.h"                   // ARM::CMSIS:RTOS:Keil RTX ext
#include "log_app.h"             /* Logging of errors */
#include "patch_rom_table.h"
#include "string.h"
#include "add_on_features.h"
#include "uart_drv.h"                // uart driver functions
#include "pmbus_mfr_specific_handlers.h"
/**
 * Main entry point of the user application.  Good place to set breakpoint when debugging a patch.
 */

void patch_pmbus_mfr_autogen_init(void);


void patch_pmbus_mfr_autogen_init(void)
{
	pmbus_mfr_autogen_init();
}

/**
 * Example how to setup a user thread for RTX RTOS.  Note only 1 USER thread is allowed to memory allocation.
 */
STATIC void USER_Thread(void const* arg);
/*lint -esym(844, tid_USER_Thread) */
osThreadId tid_USER_Thread;
osThreadDef(USER_Thread, osPriorityNormal, 1, OS_THREAD_STACK_SIZE);

STATIC void USER_Thread(void const* arg)
{
	// Insert 1 time init code here:

	/* thread loop */
	for(;;)
	{
		// update status_word every 1 ms
		status_word_update();
	}
}


/**
 * Main entry point of the user application.  Good place to set breakpoint when debugging a patch.
 * This will only get executed a single time prior to configuration loading and before RTOS starts
 */

void user_drv_init(void)
{
	memset(&user_data, 0, sizeof(USER_DATA_t));  // ZI the user data

	tid_USER_Thread = osExtThreadCreate(osThread(USER_Thread), NULL);
	THROW_IF((tid_USER_Thread == NULL), OUT_OF_RESOURCE); /* osErrorNoMemory */

	// this is the initialization of user pmbus commands autogenerated from pmbus spreadsheet
	ptr_mfr_specific_init = (mfr_specific_init_ptr) patch_pmbus_mfr_autogen_init;

	// set the pointer funtion in init of regulation state machine to user callback setup for each state
	set_module_init_cb(MODULE_REGULATION, regulation_sm_callbacks_init);

	add_on_features_init();
	regulation_sm_callbacks_init();
	patch_pmbus_mfr_autogen_init();

}



/*
 * status_word_update() function checks if there is only PG_STATUS is set as "1"
 * if only PG_STATUS = 1, then NON_OF_THE_ABOVE bit will be cleared.
 * This function is called in USER_Thread every 1 ms
 */

void status_word_update()
{
	uint32_t data;

	// we ignore writes to status word and just re-populate the command with the read data,
	// need to update both loops because of first to assert will update on both on each smbalert change
	data = PMBUS_STATUS_WORD__GET((pmbus_status_loop_idx_t)PMBUS_PAGE_0);

	/*	data>>8		data
	 * 	7			15  VOUT  An output voltage fault or warning has occurred.
		6			14  IOUT/POUT  An output current or output power fault or warning has occurred.
		5			13  INPUT  An input voltage, input current, or input power fault or warning has occurred.
		4			12  MFRSPECIFIC  A manufacturer specific fault or warning has occurred.
		3			11  PG_STATUS#  The POWER_GOOD signal, if present, is negated
		2			10  FANS  A fan or airflow fault or warning has occurred.
		1			9  OTHER  A bit in STATUS_OTHER is set
		0			8  UNKNOWN
	 *
	 */

	if ( ( (data & (~(1<<(uint16_t)PMBUS_STATUS_POWER_GOOD)) ) >> 8 ) == 0)		// to check if PG_STATUS only one is "1" in 12:8 bits
	{
		data &= ~1;	// to clear 1sr bit NONE_OF_THE_ABOVE
	}

	PMBUS_Set_Command_Word((PMBUS_PAGE_W_BROADCAST_t)PMBUS_PAGE_0, PMBUS_CMDCODE_STATUS_WORD, (uint16_t)data);
	PMBUS_Set_Command_Byte((PMBUS_PAGE_W_BROADCAST_t)PMBUS_PAGE_0, PMBUS_CMDCODE_STATUS_BYTE, (uint8_t)data);

	data = PMBUS_STATUS_WORD__GET((pmbus_status_loop_idx_t)PMBUS_PAGE_1);

	if ( ( (data & (~(1<<(uint16_t)PMBUS_STATUS_POWER_GOOD)) ) >> 8 ) == 0)
	{
		data &= ~1;	// to clear 1sr bit NONE_OF_THE_ABOVE
	}

	PMBUS_Set_Command_Word((PMBUS_PAGE_W_BROADCAST_t)PMBUS_PAGE_1, PMBUS_CMDCODE_STATUS_WORD, (uint16_t)data);
	PMBUS_Set_Command_Byte((PMBUS_PAGE_W_BROADCAST_t)PMBUS_PAGE_1, PMBUS_CMDCODE_STATUS_BYTE, (uint8_t)data);

	// code below here is equivalent to these 2 calls, but we want to avoid lint recursion:
	// we want to update status other from the hardware register so we read the registers of each loop
	// and write back the value into the pmbus command here.  This is because the status other
	// detection is driven completely by hw so no need to look at prior fw pmbus command value
	//PMBUS_HANDLE_STATUS_OTHER(PMBUS_PAGE_0, PMBUS_PEEK);   // update status other based on hw set of first to assert
	//PMBUS_HANDLE_STATUS_OTHER(PMBUS_PAGE_1, PMBUS_PEEK);   // update status other based on hw set of first to assert

	uint8_t cmd = PMBUS_CMDCODE_STATUS_OTHER;
	uint8_t latch_data;

	uint32_t * iout_addr = __PMBUS_STATUS_IOUT__ADDRESS((pmbus_status_loop_idx_t)PMBUS_PAGE_0);
	uint32_t * base_addr = __PMBUS_STATUS_VOUT__ADDRESS((pmbus_status_loop_idx_t)PMBUS_PAGE_0);  // base offset to start from
	uint32_t * register_offset = base_addr + (cmd - PMBUS_CMDCODE_STATUS_VOUT) * 	// index from cmd argument
		(iout_addr - __PMBUS_STATUS_VOUT__ADDRESS((pmbus_status_loop_idx_t)PMBUS_PAGE_0));  // offset between registers

	latch_data = (uint8_t)HAL_GET32(register_offset);
	PMBUS_Set_Command_Byte(PMBUS_PAGE_WB_0, cmd, latch_data);

	iout_addr = __PMBUS_STATUS_IOUT__ADDRESS((pmbus_status_loop_idx_t)PMBUS_PAGE_1);
	base_addr = __PMBUS_STATUS_VOUT__ADDRESS((pmbus_status_loop_idx_t)PMBUS_PAGE_1);  // base offset to start from
	register_offset = base_addr + (cmd - PMBUS_CMDCODE_STATUS_VOUT) * 	// index from cmd argument
		(iout_addr - __PMBUS_STATUS_VOUT__ADDRESS((pmbus_status_loop_idx_t)PMBUS_PAGE_1));  // offset between registers

	latch_data = (uint8_t)HAL_GET32(register_offset);
	PMBUS_Set_Command_Byte(PMBUS_PAGE_WB_1, cmd, latch_data);

}






